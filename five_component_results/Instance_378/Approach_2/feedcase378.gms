
******************************************************************
******************************************************************
*
* DOWNLOADED FROM MINLP CYBER-INFRASTRUCTURE
* www.minlp.org
*
* PROBLEM : Optimal Separation Sequences Based on Distillation: From Conventional to Fully Thermally Coupled Systems
*
* AUTHOR(S) : Jose Caballero, Ignacio Grossmann
*
* SUBMITTED BY : Jose Caballero

******************************************************************
******************************************************************
$OnText
The code is modifed by Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit
Tawarmalani to identify the distillation sequence that requires the least vapor
duty. Comments are made to poinout the changes made to the code.
$OffText


$OFFSYMXREF
$OFFSYMLIST

* ====== options list====================================================
$OnText
option limrow=0;
option limcol=0;
option iterlim=100000000;
option reslim = 10000000;
option solprint=on;
option sysout=off;
option nlp=conopt;
option minlp=sbb;
option optcr=0;
option mip=cplex;
$OffText

* Only the following three options are required (Radhakrishna Tumbalam Gooty,
* Rakesh Agrawal and Mohit Tawarmalani)
option reslim = 18000;
option minlp = baron;
option optcr = 0.01;

*=============================================================================

$Ontext

        THERMALLY COUPLED DISTILLATION.

         This model obtain the optimal (minimum cost) sequence among all the
         alternaives sequences for mixtures of 5 components that do not form
         azeotropes and have near ideal behaviour.

         The model uses a modified version of the Fenske-Underwood shortcut
         equations.

         See:

         for a detailded description of the model.

         PART I.
         A set of logical relationships that assure only basic sequences
         together with all the posibilities for internal heat exchangers.


         Logical constraints:

                1.- A given state can produce at most, a separation task

                2.- A given state can be produced by, at most two tasks.
                    If it is produced by two tasks, one must be from a rectyfing section
                    and the other from a stripping section

                3.-  Lightest and heviest final products are produced only by a column
                     the rest can be produced by one or two contributions (more than
                     two produce non-basic seuquences).
                      If it is produced by two tasks, one must be from a rectyfing section
                      and the other from a stripping section

                5.- Connectivity equations

         Superstructure (based on states)

                                                  A
                                          AB
                                  ABC             B
                          ABCD            BC
                 ABCDE            BCD             C
                          BCDE            CD
                                  CDE             D
                                          DE
                                                  E


Note: code for separation tasks:
         1.- A/BCDE  2.- AB/BCDE  3.- AB/CDE   4.- ABC/BCDE    5.- ABC/CDE
         6.- ABC/DE  7.- ABCD/BCDE 8.- ABCD/CDE  9.- ABCD/DE  10.- ABCD/E

         11.- A/BCD  12.- AB/BCD  13.- AB/CD  14.- ABC/BCD  15.- ABC/CD  16.- ABC/D
         17.- B/CDE  18.- BC/CDE  19.- BC/DE  20.- BCD/CDE  21.- BCD/DE  22.- BCD/E

         23.- A/BC  24.- AB/BC  25.- AB/C
         26.- B/CD  27.- BC/CD  28.- BC/D
         29.- C/DE  30.- CD/DE  31.- CD/E

         32.- A/B  33.- B/C  34 C/D   35.- D/E

$Offtext ;

*==================================================================================================
*        PARTE I LOGICAL RELATIONSHIPS

SETS

         t       tasks          /t1*t35/
         s       states         /ABCDE, ABCD, BCDE, ABC, BCD, CDE,
                                 AB, BC, CD, DE, A, B, C, D, E/

         c(s)    pseudo-columns  /ABCDE, ABCD, BCDE, ABC, BCD, CDE, AB, BC, CD, DE/
         P(s)    final products  /A, B, C, D, E/

        oST(s,t) tasks generated by state s

                 /ABCDE.(t1*t10), ABCD.(t11*t16), BCDE.(t17*t22)
                  ABC.(t23*t25), BCD.(t26*t28), CDE.(t29*t31)
                  AB.(t32), BC.(t33), CD.(t34), DE.(t35) /

        iST(s,t) p-columns that produce the state s

              / ABCD.(t7,t8,t9,t10), BCDE.(t1,t2,t4,t7), ABC.(t4,t5,t6,t14,t15,t16)
                BCD.(t11,t12,t14,t20,t21,t22), CDE.(t3,t5,t8,t17,t18,t20)
                AB.(t2,t3,t12,t13,t24,t25), BC.(t18,t19,t23,t24,t27,t28)
                CD.(t13,t15,t26,t27,t30,t31), DE.(t6,t9,t19,t21,t29,t30) /


        DiST(s,t)  p-columns that produce the state s through a rectyfing section

                / ABCD.(t7,t8,t9,t10), ABC.(t4,t5,t6,t14,t15,t16)
                  BCD.(t20,t21,t22), AB.(t2,t3,t12,t13,t24,t25)
                  BC.(t18,t19,t27,t28), CD.(t30,t31) /

        BiST(s,t) p-columns that produce the state s through a stripping section
                / BCDE.(t1,t2,t4,t7), BCD.(t11,t12,t14)
                  CDE.(t3,t5,t8,t17,t18,t20), BC.(t23,t24)
                  CD.(t13,t15,t26,t27), DE.(t6,t9,t19,t21,t29,t30) /

        DiSTT(s,t)
        BiSTT(s,t)

        PRODR(s,t) pure products generated by tasks t by a rectyfing section

                /A.(t1,t11,t23,t32), B.(t17,t26,t33), C.(t29,t34), D.(t35) /

        PRODS(s,t) pure products generated by tasks t by a rectyfing section

                /B.(t32), C.(t25,t33), D.(t16,t28,t34), E.(t10,t22,t31,t35)/

        PRODT(s,t)


        ;

        PRODT(s,t) = PRODR(s,t) + PRODS(s,t);
        DiSTT(s,t) = DiST(s,t) + PRODR(s,t);
        BiSTT(s,t) = BiST(s,t) + PRODS(s,t);

;
alias(t,tt);
alias(s,ss);

SETS

        INT_HE(s,t,tt)  stripping-rectyfing section in intermediate heat exchangers

               /BCD.(t11,t12,t14).(t20,t21,t22)
                BC.(t18,t19,t27,t28).(t23,t24)
                CD.(t30,t31).(t13,t15,t26,t27)/
        ;

SCALAR
        N       number of components /5/;


BINARY VARIABLES

         y(t)    task t exists
         Wbin(s)  Heat exchanger associated to state s exists
;
VARIABLE
         W(s) idem that Wbin but used to relax integrality of Wbin
         WR(s), WC(s)       heat exchanger is a reboiler or a condenser;
VARIABLE
         z(s)  state s exists view note
         zobj  funcion objetivo;

* Note: z(s) and y(t) behave are 'strictly speaking' binaries, however only is
*       necessary to define one as binary, logical relations assure that the other
*       take integer values. Numerical resuls showed that better results were obtained
*       using y(t) as binary even though the number of such variables is larger than z(s)!!!

EQUATIONS
*         dummy (RTG, RA and MT: This is not needed. So, it is commented out)
         logic1, logic2, logic3, logic4, logic5, logic6
         logic7, logic8, logic9, logic10, logic11, logic12
         logic13, logic14, logic15
         logicaux, logicaux2
         heat5, heat6, heat7, heat8, heat9, heat10;
$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
Equations heat5, heat6, heat7, heat8, heat9 and heat10 can be found in part III
of the code. We are just moving those equations to the end of search space
formulation part, without making any changes to them.
$OffText

* dummy..  zobj=e= 1; (RTG, RA and MT: This is not needed. So, it is commented out)

*                A given state can produce at most, a separation task

logic1(c(s))..            sum(t$(oST(s,t)), y(t)) =l= 1;

*                A given state can be produced by, at most two tasks.
*                  If it is produced by two tasks, one must be from a rectyfing section
*                  and the other from a stripping section

logic2(c(s))..           sum(t$(DiST(s,t)), y(t)) =l= 1;
logic3(c(s))..           sum(t$(BiST(s,t)), y(t)) =l= 1;

*                Lightest and heviest final products are produced only by a column
*                 the rest can be produced by one or two contributions (more than
*                 two produce non-basic seuquences).
*                 If it is produced by two tasks, one must be from a rectyfing section
*                 and the other from a stripping section
*                 If it is produced only by one contribution a heat exchanger must appear


logic4(P(s))..     sum(t$(PRODT(s,t)), y(t)) =g= 1;
logic5(P(s))..     sum(t$(PRODR(s,t)), y(t)) =l= 1;
logic6(P(s))..     sum(t$(PRODS(s,t)), y(t)) =l= 1;

*                  Relations heat exchangers tasks

logic7(P(s))..   sum(t$(PRODR(s,t)), y(t)) + W(s) =g= 1;
logic8(P(s))..   sum(t$(PRODS(s,t)), y(t)) + W(s) =g= 1;

logic9(P(s),t,tt)$(PRODR(s,t) AND PRODS(s,tt)).. 1-y(t) + 1-y(tt) + 1-W(s) =g= 1;

*      Logic for intemediate heat exchangers

logic10(c(s))$(ord(s) gt 1).. 1-W(s) + sum(t$(iST(s,t)),y(t)) =g= 1;

logic11(INT_HE(s,t,tt))..       1-W(s) + 1-y(t) + 1-y(tt) =g= 1;

*     Connectivity equations

logic12(iST(s,t))$(ord(s) gt 1)..  1-y(t) + sum(tt$oST(s,tt), y(tt)) =g= 1;
logic13(oST(s,t))$(ord(s) gt 1)..  1-y(t) + sum(tt$iST(s,tt), y(tt)) =g= 1;



*        relations between states and tasks     (states continuous variables tasks binaries)

logic14(oST(s,t))..              1 - y(t) + z(s) =g= 1;
logic15(c(s))..                  1 - z(s) + sum(t$oST(s,t), y(t)) =g= 1;

logicaux(P(s))..     W(s) =e= Wbin(s);
logicaux2(C(s))..    W(s) =e= Wbin(s);

* Logical relationships to determine if a heat exchanger is a condenser or a reboiler

heat5(s)..                WR(s) + WC(s) =l= 1;
heat6(s)..                W(s) =e= WR(s) + WC(s);
heat7(DiST(s,t))..        1-y(t) + 1-W(s) + WC(s) =g= 1;
heat8(PRODR(s,t))..       1-y(t) + 1-W(s) + WC(s) =g= 1;
heat9(BiST(s,t))..        1-y(t) + 1-W(s) + WR(s) =g= 1;
heat10(PRODS(s,t))..      1-y(t) + 1-W(s) + WR(s) =g= 1;

*==========================================================================================
$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
This part is suppressed, since we will not decompose the MINLP


*        BINARY CUT


SET
         it /1*20/;

PARAMETERS
ITER, B1(s,it), N1(s,it)
;

EQUATIONS
         cut1;

Cut1(it)$((ord(it) gt 1) AND (ord(it) le ITER))..
         sum(s, B1(s,it)*z(s)) - sum(s, N1(s,it)*z(s)) =l= sum(s, B1(s,it)) - 1;

$OffText
*=======================================================================================


alias(s,ss);
alias(s,sss);

*        PART II COLUMN EQUATIONS: SHORTCUT METHOD OF UNDERWOOD GILLILAN FENSKE

SETS
         i components /A, B, C, D, E/
         r Underwood roots /r1, r2, r3, r4/

         RUA(s,r) active underwood roots in the colunm c
                 /ABCDE.(r1,r2,r3,r4), ABCD.(r1,r2,r3), BCDE.(r2,r3,r4)
                  ABC.(r1,r2), BCD.(r2,r3), CDE.(r3,r4)
                  AB.r1, BC.r2, CD.r3, DE.r4/

         COLD(s,ss)      column s sends distillate to column ss
                  /ABCDE.ABCD, ABCD.ABC, ABC.AB, BCDE.BCD, BCD.BC, CDE.CD/

         COLB(s,ss)      column s sends bottoms to column ss
                  /ABCDE.BCDE, BCDE.CDE, CDE.DE, ABCD.BCD, BCD.CD, ABC.BC/


         COLDT(s,ss)      same as COLD including final products
                  /ABCDE.ABCD, ABCD.ABC, ABC.AB, AB.A, BCDE.BCD, BCD.BC,BC.B, CDE.CD, CD.C, DE.D/

         COLBT(s,ss)      same as COLDB including final products
                  /ABCDE.BCDE, BCDE.CDE, CDE.DE, DE.E, ABCD.BCD, BCD.CD, CD.D, ABC.BC, BC.C, AB.B/


         ARRIBA(s) /ABCD, ABC, AB/
         ABAJO(s) /BCDE, CDE, DE/

         CAMCAL(s,ss) possible heat exchange between condenser s and reboiler ss
                 /A.(BC,BCD,BCDE,C,CD,CDE,D,DE,E), AB.(BCD,BCDE,C,CD,CDE,D,DE,E)
                  ABC.(B,BCDE,C,CD,CDE,D,DE,E), ABCD.(B,BC,C,CD,CDE,D,DE,E)
                  B.(BC,BCD,BCDE,C,CD,CDE,D,DE,E), BC.(B,BCD,BCDE,C,CD,CDE,D,DE,E)
                  BCD.(B,BC,BCDE,C,CD,CDE,D,DE,E), BCDE.(B,BC,BCD,C,CD,CDE,D,DE,E)
                  C.(B,BC,BCD,BCDE,CD,CDE,D,DE,E), CD.(B,BC,BCD,BCDE,C,CDE,D,DE,E)
                  D.(B,BC,BCD,BCDE,C,CD,CDE)/

         COLT(s,ss)
;
         COLT(s,ss) = COLDT(s,ss) + COLBT(s,ss);

alias(i,j);


$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
These values are not needed for vapor duty objective function
         MM  big M /1000/
         MMM big M /1/;
$OffText

Scalar 
       Ff  feed molar flow Divided by 100 /2/
       M1  big M /2.542253e+01/
       M2  big M /2/
       M   big M /200/;


Parameters 
        alpha(i)    relative volatility
                    /A   7.5625
                     B   6.875
                     C   6.25
                     D   2.5
                     E   1/

        zf(i)    feed mole fraction
                    /A   0.05
                     B   0.05
                     C   0.425
                     D   0.425
                     E   0.05/

        LK(t)    position number of the light key
                 /t1   1, t2   1, t3   2, t4   1, t5   2, t6   3, t7   1
                 t8   2, t9   3, t10  4, t11  1, t12  1, t13  2, t14  1
                 t15  2, t16  3, t17  2, t18  2, t19  3, t20  2, t21  3
                 t22  4, t23  1, t24  1, t25  2, t26  2, t27  2, t28  3
                 t29  3, t30  3, t31  4, t32  1, t33  2, t34  3, t35  4 /


        HK(t)    position number of the heavy key
                /t1   2, t2   3, t3   3, t4   4, t5   4, t6   4, t7   5
                 t8   5, t9   5, t10  5, t11  2, t12  3, t13  3, t14  4
                 t15  4, t16  4, t17  3, t18  4, t19  4, t20  5, t21  5
                 t22  5, t23  2, t24  3, t25  3, t26  3, t27  4, t28  4
                 t29  4, t30  5, t31  5, t32  2, t33  3, t34  4, t35  5 /
;

$OnText
VARIABLES
         zobj   objective function
         zobj2;
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
Variable for objective function definition has already been defined. So, this
part is commented out
$OffText

POSITIVE VARIABLES
        V1(s), V2(s), L1(s), L2(s)   "total flows (kmol/h) of vapor and liquid in rec and str sections"
        F(s), D(s), B(s)             "total flows (kmol/h) of feed, distillate and bottoms"
        Fi(s,i), Di(s,i), Bi(s,i)    "individual flows (kmol/h) of feed, distillate and bottoms"
        rud(s,r)                     Underwood root

;

EQUATIONS

         objfun
*         objfunk (RTG, RA and MT: This is not needed when solving the MINLP as whole)
         eq1, eq1b, eq2, eq2b, eq3, eq4, eq5, eq6a, eq6b, eq7a, eq7b,
         eq8,
         eq10, eq11, eq12, eq13,eq14, eq15, eq16,eq17, eq18,
         eq19, eq20, eq21, eq22, eq23, eq24, eq25, eq26, eq27,  eq28
         eq29,  eq30, eq31, eq32, eq33, eq34, eq35, eq36, eq37, eq38
         eq39, eq40, eq41, eq42, eq43, eq44, eq45, eq46, eq47, eq48, eq49
         uw1a, uw1b,  uw2, uw3
;


* Feed is assigned to first column

eq1(i,s)$(ord(s) eq 1)..       Fi(s,i) =e= Ff*zf(i);
eq1b(s)$(ord(s) eq 1)..        V2(s) =e= V1(s);

* mass balances

eq2(c(s),i)..     Fi(s,i) =l= Di(s,i) + Bi(s,i) + M2*(1-z(s));
eq2b(c(s),i)..    Fi(s,i) =g= Di(s,i) + Bi(s,i) - M2*(1-z(s));

eq3(c(s))..       F(s) =e= sum(i, Fi(s,i));
eq4(c(s))..       D(s) =e= sum(i, Di(s,i));
eq5(c(s))..       B(s) =e= sum(i, Bi(s,i));

eq6a(c(s))..       D(s) =l= V1(s) - L1(s) + M1*(1-z(s));
eq6b(c(s))..       D(s) =g= V1(s) - L1(s) - M1*(1-z(s));

eq7a(c(s))..       B(s) =l= L2(s) - V2(s) + M1*(1-z(s));
eq7b(c(s))..       B(s) =g= L2(s) - V2(s) - M1*(1-z(s));


* Mass balances among columns

*        columns exists
*                this equatuion does not depend on the thermal state of stream

eq8(c(ss),i)$(ord(ss) gt 1)..
                 Fi(ss,i) =e= sum(s$COLD(s,ss), Di(s,i)) + sum(s$COLB(s,ss), Bi(s,i)) ;

*                There is not heat exchanger associated to state ss (this equation appear even
*                in the case in which there is not state ss)

eq10(c(ss))$(ord(ss) gt 1)..
                 V1(ss) + sum(s$COLB(s,ss),V2(s)) - V2(ss) - sum(s$COLD(s,ss), V1(s)) =l= M1*W(ss);
eq11(c(ss))$(ord(ss) gt 1)..
                 V1(ss) + sum(s$COLB(s,ss),V2(s)) - V2(ss) - sum(s$COLD(s,ss), V1(s)) =g= -M1*W(ss);

eq12(c(ss))$(ord(ss) gt 1)..
                 L1(ss) + sum(s$COLB(s,ss),L2(s)) - L2(ss) - sum(s$COLD(s,ss), L1(s)) =l= M1*W(ss);
eq13(c(ss))$(ord(ss) gt 1)..
                 L1(ss) + sum(s$COLB(s,ss),L2(s)) - L2(ss) - sum(s$COLD(s,ss), L1(s)) =g= -M1*W(ss);

*                There is a heat exchanger NOTE: (q=1 V2=V1) (q=0 L2=L1)

eq14(c(s))..     V2(s) - V1(s) =l= M1*(1-W(s));
eq15(c(s))..     V2(s) - V1(s) =g= -M1*(1-W(s));

*        columns does not exist

eq16(c(ss))$(ord(ss) gt 1 and not ABAJO(ss))..
                 V1(ss) =l= sum(s$COLD(s,ss), V1(s)) + M1*z(ss);
eq17(c(ss))$(ord(ss) gt 1 and not ABAJO(ss))..
                 V1(ss) =g= sum(s$COLD(s,ss), V1(s)) - M1*z(ss);

eq18(c(ss))$(ord(ss) gt 1 and not ABAJO(ss))..
                 L1(ss) =l= sum(s$COLD(s,ss), L1(s)) + M1*z(ss);
eq19(c(ss))$(ord(ss) gt 1 and not ABAJO(ss))..
                 L1(ss) =g= sum(s$COLD(s,ss), L1(s)) - M1*z(ss);


eq20(c(ss))$(ord(ss) gt 1 and not ARRIBA(ss))..
                 L2(ss) =l= sum(s$COLB(s,ss), L2(s)) + M1*z(ss);
eq21(c(ss))$(ord(ss) gt 1 and not ARRIBA(ss))..
                 L2(ss) =g= sum(s$COLB(s,ss), L2(s)) - M1*z(ss);

eq22(c(ss))$(ord(ss) gt 1 and not ARRIBA(ss))..
                 V2(ss) =l= sum(s$COLB(s,ss), V2(s)) + M1*z(ss);
eq23(c(ss))$(ord(ss) gt 1 and not ARRIBA(ss))..
                 V2(ss) =g= sum(s$COLB(s,ss), V2(s)) - M1*z(ss);

eq24(c(ss),i)$(ord(ss) gt 1 and not ABAJO(ss))..
                 Di(ss,i) =l= sum(s$COLD(s,ss), Di(s,i)) + M2*z(ss);
eq25(c(ss),i)$(ord(ss) gt 1 and not ABAJO(ss))..
                 Di(ss,i) =g= sum(s$COLD(s,ss), Di(s,i)) - M2*z(ss);

eq26(c(ss),i)$(ord(ss) gt 1 and not ARRIBA(ss))..
                 Bi(ss,i) =l= sum(s$COLB(s,ss), Bi(s,i)) + M2*z(ss);
eq27(c(ss),i)$(ord(ss) gt 1 and not ARRIBA(ss))..
                 Bi(ss,i) =g= sum(s$COLB(s,ss), Bi(s,i)) - M2*z(ss);



*        Total recovery of final products

eq28..           D('AB') =e= Ff*zf('A');
eq29..           B('AB') + D('BC') =e= Ff*zf('B');
eq30..           B('BC') + D('CD') =e= Ff*zf('C');
eq31..           B('CD') + D('DE') =e= Ff*zf('D');
eq32..           B('DE') =E= Ff*zf('E');

*        If there is not final heat exchanger products are produced by 2 contributions

eq33..           L2('AB') - L1('BC') =l= Ff*zf('B') + M1*W('B');
eq34..           L2('AB') - L1('BC') =g= Ff*zf('B') - M1*W('B');
eq35..           L2('BC') - L1('CD') =l= Ff*zf('C') + M1*W('C');
eq36..           L2('BC') - L1('CD') =g= Ff*zf('C') - M1*W('C');
eq37..           L2('CD') - L1('DE') =l= Ff*zf('D') + M1*W('D');
eq38..           L2('CD') - L1('DE') =g= Ff*zf('D') - M1*W('D');

*        forzing some zeros if limiting columns does not exist

eq39(ARRIBA(s))..        V2(s) =l= M1*z(s);
eq40(ARRIBA(s))..        L2(s) =l= M1*z(s);
eq41(ABAJO(s))..         V1(s) =l= M1*z(s);
eq42(ABAJO(s))..         L1(s) =l= M1*z(s);


* Recovery of each column. total split

eq43(oST(s,t),i)$(ord(i) le LK(t))..      Fi(s,i) - Di(s,i) =l= M2*(1-y(t));
eq44(oST(s,t),i)$(ord(i) le LK(t))..      Fi(s,i) - Di(s,i) =g= -M2*(1-y(t));
eq45(oST(s,t),i)$(ord(i) ge HK(t))..      Di(s,i) =l= M2*(1-y(t));

*===============================================================================
$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani.

Caballero and Grossmann (2006) consider columns which are operated above 20% of
the minimum vapor requirement. That's why, they have the factor 1.2 in front of
Underwood minimum vapor constraints. However, there should not be a factor of
1.2 in front of feed equations, because V1(s)-V2(s) = V1min(s)-V2min(s) = Vin(s)

So, we make two changes:
(i). Remove the factor of 1.2 in uw1a and uw1b equations to use the correct
Underwood feed equations
(ii). We remove 1.2 in uw2 and uw3 equations to allow operation at pinch

* Underwood equations

uw1a(RUA(s,r))..   1.2*sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =l=  M*(1-z(s));
uw1b(RUA(s,r))..   1.2*sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =g=  -M*(1-z(s));

uw2(RUA(s,r))..    1.2*sum(i, alpha(i)*Di(s,i)/(alpha(i) - rud(s,r))) =l= V1(s) + M*(1-z(s));
uw3(RUA(s,r))..    -1.2*sum(i, alpha(i)*Bi(s,i)/(alpha(i) - rud(s,r))) =l= V2(s) + M*(1-z(s));
$OffText
*===============================================================================
* Underwood equations
$OnText
uw1a(RUA(s,r))..   sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =l=  M*(1-z(s));
uw1b(RUA(s,r))..   sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =g=  -M*(1-z(s));

uw2(RUA(s,r))..    sum(i, alpha(i)*Di(s,i)/(alpha(i) - rud(s,r))) =l= V1(s) + M*(1-z(s));
uw3(RUA(s,r))..    sum(i, alpha(i)*Bi(s,i)/(alpha(i) - rud(s,r))) =l= V2(s) + M*(1-z(s));
$OffText

$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
Qreb(s): Vapor flow generated in each reboiler. Note that the constraints on
Qreb are imposed in the same as way Caballero and Grossmann. Since, our
objective is vapor duty and we assumed that the latent heat of vaporization
is the same for all components, the constraints look simpler
$OffText

POSITIVE VARIABLES
         Qreb(s)                      Heat load in reboiler and condenser
         V1min(s), V2min(s)           Minimum Vapor in each section;

$OnText
CORRECTED MODEL
$OffText

*$OnText
Equations   uw4, uw5, uw6, uw7, uw8, uw9, uw10, uw11;

uw1a(RUA(s,r))..   sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =l=  M*(1-z(s));
uw1b(RUA(s,r))..   sum(i, alpha(i)*Fi(s,i)/(alpha(i) - rud(s,r))) - (V1(s) - V2(s)) =g=  -M*(1-z(s));

uw2(RUA(s,r))..    sum(i, alpha(i)*Di(s,i)/(alpha(i) - rud(s,r))) =l= V1min(s) + M*(1-z(s));
uw3(RUA(s,r))..   -sum(i, alpha(i)*Bi(s,i)/(alpha(i) - rud(s,r))) =l= V2min(s) + M*(1-z(s));

uw4.. V1min('ABCDE') =l= sum(i, alpha(i)*Di('ABCDE',i)/(alpha(i) - rud('ABCDE','r2'))) + M*(1-y('t4')-y('t7'));
uw5.. V2min('ABCDE') =l= -sum(i, alpha(i)*Bi('ABCDE',i)/(alpha(i) - rud('ABCDE','r2'))) + M*(1-y('t4')-y('t7'));
uw6.. V1min('ABCDE') =l= sum(i, alpha(i)*Di('ABCDE',i)/(alpha(i) - rud('ABCDE','r3'))) + M*(1-y('t8')-y('t7'));
uw7.. V2min('ABCDE') =l= -sum(i, alpha(i)*Bi('ABCDE',i)/(alpha(i) - rud('ABCDE','r3'))) + M*(1-y('t8')-y('t7'));
uw8.. V1min('ABCD') =l= sum(i, alpha(i)*Di('ABCD',i)/(alpha(i) - rud('ABCD','r2'))) + M*(1-y('t14'));
uw9.. V2min('ABCD') =l= -sum(i, alpha(i)*Bi('ABCD',i)/(alpha(i) - rud('ABCD','r2'))) + M*(1-y('t14'));
uw10.. V1min('BCDE') =l= sum(i, alpha(i)*Di('BCDE',i)/(alpha(i) - rud('BCDE','r3'))) + M*(1-y('t20'));
uw11.. V2min('BCDE') =l= -sum(i, alpha(i)*Bi('BCDE',i)/(alpha(i) - rud('BCDE','r3'))) + M*(1-y('t20'));
*$OffText


eq46(c(s))..    V1min(s) =l= V1(s);
eq47(c(s))..    V2min(s) =l= V2(s);
eq48(c(s))..    Qreb(s) - V2(s) =g= -M1*(1 - sum(ss$COLBT(s,ss), WR(ss)));
eq49(c(s))..    Qreb(s) - V2(s) =l=  M1*(1 - sum(ss$COLBT(s,ss), WR(ss)));

objfun..         zobj =e= sum(s, Qreb(s));

*========================================================================================================
$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
This part is not required for vapor duty objective function and is suppressed

* PART III.- SIZING COSTING AND ENERGY BALANCES

PARAMETERS
         Pr   Nominal pressure
         NPmin(t) minimum number of trays in task t
         NP(t) actual number of trays calculaed as 2*NPmin
         NPmax max number of trays
         H(t)  length of the column t
         PPM   molecular weight

         PM(i) molecular weight /A 78
                                 B 92
                                 C 106
                                 D 104
                                 E 118/

         Hvap(i) vaporization enthalpy KJmol-1 /A  30.77
                                                   B  33.19
                                                   C  35.58
                                                   D  36.83
                                                   E  38.30 /
         roL liquid dessity ssumed constant kg m-3
         rov Vapor density calculated in feed tray
         rec recovery of each component in a column
         Tf feed temperature;

rec=0.98;
NPmin(t) = log(rec**2/(1-rec)**2)/log(sum(i$(ord(i) eq LK(t)),alpha(i))/sum(i$(ord(i) eq HK(t)),alpha(i)));
NP(t) = 2*NPmin(t);
NPmax = smax(t, NP(t));
roL=810;
PPM   = sum(i, zf(i)*PM(i));
Tf = 85.122;
Pr = 0.5;
rov =  PPM*Pr/0.082/(Tf + 273) ;
H(t) = NP(t)*0.6 + 4;



POSITIVE VARIABLES


         WR(s), WC(s)       heat exchanger is a reboiler or a condenser
         Qreb(s), Qcond(s)  Heat load in reboiler and condenser


         Ar(s)              Area of columns s
         Volumen(t)         Volumen in the column t
         Vol(s)             Volumen of the task s

         Cpisos(s)          Related to cost estimation
         CostPisos
         CP(s)
         CostColumn(s)
         NumPisos(s)
         VV(s)           max of V1 and V2;


EQUATIONS
         objfun2
*         heat1,heat2, heat3, heat4,
         heat5, heat6, heat7, heat8, heat9, heat10
         heat11, heat12, heat13, heat14
         Area1, Area2, Area3, Area4, Area5, Area6
         Coste1, Coste2, Coste3, Coste4, Coste5
         ;


* buble temperature in the feed of state s

*heat1(C(s),i)..       Pv(s,i) =e= exp(  ANT_A(i) - ANT_B(i)/(Te(s) + ANT_C(i))  );
*heat2(C(s))..    sum(i, (Pr - Pv(s,i))*FI(s,i)) =l= MM*(1-z(s));
*heat3(C(s))..    sum(i, (Pr - Pv(s,i))*FI(s,i)) =g= - MM*(1-z(s));

* Calculation of Temperature of products

*heat4(P(s),i)$(ord(s) eq ord(i) + card(s)-N)..
*                         exp(  ANT_A(i) - ANT_B(i)/(Te(s) + ANT_C(i))  )  =e= Pr;

* Logical relationships to determine if a heat exchanger is a condenser of a reboiler

heat5(s)..       WR(s) + WC(s) =l= 1;
heat6(s)..       W(s) =e= WR(s) + WC(s);
heat7(DiST(s,t))..        1-y(t) + 1-W(s) + WC(s) =g= 1;
heat8(PRODR(s,t))..       1-y(t) + 1-W(s) + WC(s) =g= 1;
heat9(BiST(s,t))..        1-y(t) + 1-W(s) + WR(s) =g= 1;
heat10(PRODS(s,t))..      1-y(t) + 1-W(s) + WR(s) =g= 1;

* Calculation of heat loads in condenser and reboiler

heat11(COLDT(s,ss))..    100*Qcond(ss)*D(s) - V1(s)*sum(i,Di(s,i)*Hvap(i)) =g= -MM*(1-WC(ss));
heat12(COLDT(s,ss))..    100*Qcond(ss)*D(s) - V1(s)*sum(i,Di(s,i)*Hvap(i)) =l= MM*(1-WC(ss));

heat13(COLBT(s,ss))..    100*Qreb(ss)*B(s) - V2(s)*sum(i,Bi(s,i)*Hvap(i)) =g= -MM*(1-WR(ss));
heat14(COLBT(s,ss))..    100*Qreb(ss)*B(s) - V2(s)*sum(i,Bi(s,i)*Hvap(i)) =l= MM*(1-WR(ss));


* Determination of the area in each column section

Area1(oST(s,t))..     Volumen(t) =E= Ar(s)*H(t) ;
Area2(oST(s,t))..     Vol(s) =G= Volumen(t) - 1000*(1-y(t));

*Area3(C(s))..   rov(s) =l= PPM*Pr/0.082/(Te(s) + 273) + MM*(1-z(s));
Area4(C(s))..   Ar(s) =g= PPM/sqrt(roL*rov)/0.6/329/0.8*VV(s)*100 - MM*(1-z(s));

Area5(C(s))..    VV(s) =g= V1(s);
Area6(C(s))..    VV(s) =g= V2(s);

*     Estimation of the cost of trays (in $*10000)

Coste1(C(s))..     Cpisos(s) =e= 1/10000*(571.1 + 406.8*Ar(s) + 22.83*Ar(s)**2);

Coste2(oST(s,t))..    NumPisos(s) =G= NP(t) - NPmax*(1-y(t)); ;
Coste3..              CostPisos =e= sum(s, Cpisos(s)*NumPisos(s))*1.2;

Coste4(C(s))..      CP(s) =g= (603.8*Vol(s) + 5307)/10000 - 15*(1-z(s));
Coste5(C(s))..      CostColumn(s) =E= CP(s)*(2.50 + 1.72);

$OffText

*_______________________________________________________________________________
$Ontext
         objective functions

         costs of utilities      Vapor  5.09 $/GJ
                                 Water  0.19 $/GJ

         Heat is in  KJ/mol and divided by 100 to scale,  in a calculation base of
         1 Kmol/h. Taking into account that we are feeding to the system 200 kmol/h
         assuming  8000 h/year

         The energy cost is
          Qreb*100 (KJ/mol)*200(Kmol/h)*8000(h/year) 1000(mol/kmol)*10-6(GJ/KJ)= [GJ/year]

        Everything is divided by 10000 to express in decens of thousand of dollars

         zobj   makes reference to total costs
         zobj2  only takes into account the energy costs.

$Offtext
*_______________________________________________________________________________

$OnText
objfun..         zobj =E= 1/10000*(
                                 100*Ff*100*8000*1000/1e6*sum(s, 5.09*Qreb(s) + 0.19*Qcond(s) )
                                 ) +
                                 1*(sum(s,CostColumn(s)) + CostPisos) +
                                 1/10000*sum(s, 15000*W(s));


objfun2..        zobj2 =E= 1/10000*(
                            100*Ff*100*8000*1000/1e6*sum(s, 5.09*Qreb(s) + 0.19*Qcond(s) )
                            );


$OffText
*===============================================================================

*        Bounds and specifications
*_______________________________________________________________________________

rud.lo(s,'r1') = alpha('B') + 0.0001;        rud.up(s,'r1') = alpha('A') - 0.0001;
rud.lo(s,'r2') = alpha('C') + 0.0001;        rud.up(s,'r2') = alpha('B') - 0.0001;
rud.lo(s,'r3') = alpha('D') + 0.0001;        rud.up(s,'r3') = alpha('C') - 0.0001;
rud.lo(s,'r4') = alpha('E') + 0.0001;        rud.up(s,'r4') = alpha('D') - 0.0001;

rud.l(s,'r1') = (alpha('A') + alpha('B'))/2;
rud.l(s,'r2') = (alpha('B') + alpha('C'))/2;
rud.l(s,'r3') = (alpha('C') + alpha('D'))/2;
rud.l(s,'r3') = (alpha('D') + alpha('E'))/2;

$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
Qcond.lo(s)=0;           Qcond.l(s)=.3;          Qcond.up(s) = 10;
Qreb.lo(s)=0;            Qreb.l(s)=.4;           Qreb.up(s) = 10;


Ar.lo(s)=.1;             Ar.l(s)=2;               Ar.up(s)=25;

Cp.lo(s)=0;              Cp.l(s)=5;               Cp.up(s)=100;
                                                  CostColumn.up(s)=1e7/10000;
$OffText

V1min.up(s) = M1;
V2min.up(s) = M1;
V1.up(s) = M1;
V2.up(s) = M1;
L1.up(s) = M1;
L2.up(s) = M1;
Qreb.up(s) = M1;

Fi.up(s,i) = Ff*zf(i);
Di.up(s,i) = Ff*zf(i);
Bi.up(s,i) = Ff*zf(i);

F.up(s) = Ff;
D.up(s) = Ff;
B.up(s) = Ff;

V1.l(s) = 1;
L1.l(s) = 1;
V2.l(s) = 1;
L2.l(s) = 1;

$OnText
VV.lo(s)=0;
VV.l(s)=3;
VV.up(s)=50;
$OffText


D.l(s)=0.5;
B.l(s)=0.5;
F.l(s)=1;

z.lo(s)=0;       z.up(s)=1;
y.lo(t)=0;       y.up(t) = 1;
W.lo(s)=0;       W.up(s)=1;
WR.lo(s)=0;      WR.up(s)=1;
WC.lo(s)=0;      WC.up(s)=1;
W.fx('ABCDE')=0; W.fx('A')=1;    W.fx('E')=1;
Wbin.l('A')=1;   Wbin.l('E')=1;


$OnText
Radhakrishna Tumbalam Gooty, Rakesh Agrawal and Mohit Tawarmalani
From hereon, Caballero and Grossman (2006) implement their two-step method to
find a solution. This solution cannot guarantee global optimum. We want to solve
the problem as a single MINLP. So, we suppress this part and use the lines shown
above

model TCD /
         logic1, logic2, logic3, logic4, logic5, logic6
         logic7, logic8, logic9, logic10, logic11, logic12
         logic13, logic14, logic15,
         objfun, objfun2
         eq1, eq1b, eq2, eq2b, eq3, eq4, eq5, eq6a, eq6b, eq7a, eq7b,
         eq8, eq10, eq11, eq12, eq13,eq14, eq15, eq16,eq17, eq18,
         eq19, eq20, eq21, eq22, eq23, eq24, eq25, eq26, eq27,  eq28
         eq29,  eq30, eq31, eq32, eq33, eq34, eq35, eq36, eq37, eq38
         eq39, eq40, eq41, eq42, eq43, eq44, eq45
         uw1a, uw1b,  uw2, uw3
*        heat1, heat2, heat3,heat4,
         heat5, heat6, heat7, heat8, heat9, heat10
         heat11, heat12, heat13, heat14
         Area1, Area2,  Area4, Area5, Area6
         Coste1, Coste2, Coste3, Coste4, Coste5
         /;

model TCD2 /TCD, logicaux, logicaux2/;

TCD2.nodlim = 100000;



*=================================================================================

ITER=1;

B1(s,it)$(ord(it) eq 1) = 0;
N1(s,it)$(ord(it) eq 1) = 0;


*=========================================================================================

*        specifications

W.lo(s)=0;
W.up(s)=1;

W.fx(s)=0;

z.lo(s)=0;       z.up(s)=1;
z.fx(p(s))=0;
W.fx('ABCDE')=0;
W.fx('A')=1;
W.fx('E')=1;

WR.lo(s)=0;      WR.up(s)=1;
WC.lo(s)=0;      WC.up(s)=1;

Wbin.l('A')=1;
Wbin.l('E')=1;



*=========================================================================================






* Solving strategy. First we search among all the basic configurations
* but fixing all the intermediate heat exchangers (not those associated to final products)
* to FALSE.

*  Then we fix the basic configuration and optimize the heat exchangers structure.

* The idea below that strategy is that the dominant cost tend to be the energy, and that
* for a given basic configurationt the differences in total cost are smaller than those
* between diferent basic configurations.

* For a given basic configuration that alternative with the minmum energy consumption
* is that with the maximum possible thermal couple.

         y.lo(t)=0; y.up(t) = 1;
         W.fx(s)=0;
         W.lo(s)$(P(s)) =0;  W.up(s)$(P(s)) =1;
         W.fx('A')=1;  W.fx('E')=1;


*y.fx('t1')=1; y.fx('t17')=1;y.fx('t29')=1;y.fx('t35')=1;
         solve TCD using minlp minimizing zobj;

         y.fx(t) = y.l(t);
         W.lo(s)=0;
         W.up(s)=1;
         W.fx('ABCDE')=0;  W.fx('A')=1;  W.fx('E')=1;

*y.fx('t1')=1; y.fx('t17')=1;y.fx('t29')=1;y.fx('t35')=1;
*W.fx('BCDE') = 1; W.fx('CDE') = 1;W.fx('DE') = 1;


        solve TCD2 using minlp minimizing zobj;

         ITER = ITER + 1;
         B1(s,it)$(ord(it) = ITER) = z.l(s);
         N1(s,it)$(ord(it) = ITER) = 1-z.l(s);


 PARAMETERS
         INVESTMENT, ENERGY, TOTAL;


         INVESTMENT =    sum(s,CostColumn.l(s)) + CostPisos.l +   1/10000*sum(s, 15000*W.l(s));

         ENERGY =   1/10000*( 100*Ff*100*8000*1000/1e6*sum(s, 5.09*Qreb.l(s) + 0.19*Qcond.l(s) ));

         TOTAL = ENERGY + INVESTMENT;

         DISPLAY   TOTAL, ENERGY, INVESTMENT;


$OffText
Model  TCD  /all/;
TCD.Optfile = 378;
Solve TCD using minlp minimizing zobj;

